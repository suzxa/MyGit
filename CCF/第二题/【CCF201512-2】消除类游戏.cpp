/*
	问题描述:
		消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的
	方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多
	处可以被消除时，这些地方的棋子将同时被消除。
	　　现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。
	　　请注意：一个棋子可能在某一行和某一列同时被消除。

	输入格式:
		输入的第一行包含两个整数n,m，用空格分隔，分别表示棋盘的行数和列数。
	　　接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。

	输出格式:
		输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋
	子被消除，则对应的方格输出0，否则输出棋子的颜色编号。

	样例输入:
		4 5
		2 2 3 1 2
		3 4 5 1 4
		2 3 2 1 3
		2 2 2 4 4

	样例输出:
		2 2 3 0 2
		3 4 5 0 4
		2 3 2 0 3
		0 0 0 4 4

	样例说明:
		棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。

	样例输入:
		4 5
		2 2 3 1 2
		3 1 1 1 1
		2 3 2 1 3
		2 2 3 3 3

	样例输出:
		2 2 3 0 2
		3 0 0 0 0
		2 3 2 0 3
		2 2 0 0 0

	样例说明:
	　　棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。

	评测用例规模与约定:
	　　所有的评测用例满足：1 ≤n,m ≤30。
*/

#include <cstdio>
#include <cstdlib>

int main(){
	
	int a[35][35];
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i=1; i<=n; i++){
		for(int j=1; j<=m; j++){
			scanf("%d", &a[i][j]);
		}
	}
	
	for(int i=1; i<=n; i++){//从行开始，找出连续三个相同的数
		for(int j=1; j<=m-2; j++){
			if(abs(a[i][j]) == abs(a[i][j+1]) && abs(a[i][j+1]) == abs(a[i][j+2])){
				if(a[i][j] > 0){
					a[i][j] *= -1;
				}
				if(a[i][j+1] > 0){
					a[i][j+1] *= -1;
				}
				if(a[i][j+2] > 0){
					a[i][j+2] *= -1;
				}
			}
		}
	}
	
	for(int i=1; i<=m; i++){//从列开始，找出连续三个相同的数
		for(int j=1; j<=n-2; j++){
			if(abs(a[j][i]) == abs(a[j+1][i]) && abs(a[j+1][i]) == abs(a[j+2][i])){
				if(a[j][i] > 0){
					a[j][i] *= -1;
				}
				if(a[j+1][i] > 0){
					a[j+1][i] *= -1;
				}
				if(a[j+2][i] > 0){
					a[j+2][i] *= -1;
				}
			}
		}
	}
	
	for(int i=1; i<=n; i++){
		for(int j=1; j<=m; j++){
			if(a[i][j] < 0){
				a[i][j] = 0;
			}
			printf("%d ", a[i][j]);
		}
		printf("\n");
	}
	
	return 0;
}
























