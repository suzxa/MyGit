/*
	问题描述:
		有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次
	老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。
　　	钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有
	标识，所以老师们不会弄混钥匙。
　　	每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还
	钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大
	的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。
　　	今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、
	开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？

	输入格式:
		输入的第一行包含两个整数N,K。
　　	接下来K行，每行三个整数w,s,c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能
	有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。
　　	保证输入数据满足输入格式，你不用检查数据合法性。

	输出格式:
		输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。

	样例输入：
		5 2
		4 3 3
		2 2 7

	样例输出：
		1 4 3 2 5

	样例说明：
		第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使
	用钥匙，使用7单位时间，所以在时刻9还钥匙。
　　	每个关键时刻后的钥匙状态如下（X表示空）：
		　　时刻2后为1X345；
		　　时刻3后为1X3X5；
		　　时刻6后为143X5；
		　　时刻9后为14325。

	样例输入：
		5 7
		1 1 14
		3 3 12
		1 15 12
		2 7 20
		3 18 12
		4 21 19
		5 30 9

	样例输出：
		1 2 3 5 4

	评测用例规模与约定：
		对于30%的评测用例，1 ≤N, K ≤10, 1 ≤w ≤N, 1 ≤s, c ≤30；
	　　对于60%的评测用例，1 ≤N, K ≤50，1 ≤w ≤N，1 ≤s ≤300，1 ≤c ≤50；
	　　对于所有评测用例，1 ≤N, K ≤1000，1 ≤w ≤N，1 ≤s ≤10000，1 ≤c ≤100。
*/

#include <cstdio>
#include <algorithm>

using namespace std;

struct Teacher{
	int key;
	int time;//记录双倍的人数，一个对应借钥匙的时间，一个对应还钥匙的时间
	int temp;//标记，借钥匙为0，还钥匙为1
}P[2010];

bool cmp(Teacher a, Teacher b){//先按时间从小到大顺序排列，时间相同，就按钥匙编号从小到大排列
	if(a.time != b.time){
		return a.time < b.time;
	}else if(a.key != b.key){
		return a.key < b.key;
	}
}

int main(){
	
	int n, k;
	scanf("%d%d", &n, &k);
	int ans[n+1]={0};
	for(int i=1; i<=n; i++){//初始化钥匙盒，此时钥匙都在盒内。数组数值对应钥匙编号
		ans[i] = i;
	}
	int w, s, c;
	int m=0;
	while(k--){
		scanf("%d%d%d", &w, &s, &c);//双倍人数存储借还状态
		P[m].key = w;
		P[m].time = s;
		P[m++].temp = 0;//借
		P[m].key = w;
		P[m].time = s+c;
		P[m++].temp = 1;//还
	}
	
	//将所有时间都从小到大排好
	//此时唯一要注意的就只有同一时刻，对于同一把钥匙的处理了
	sort(P, P+m, cmp);

	int i, j;
	
	//按时间顺序，一把把借，一把把还。
	//为什么下面要先还钥匙，再借钥匙?
	//因为在同一时刻，对于同一把钥匙，你只有先还了，才能再借。
	for(i=0; i<m; i=j){//开始借还钥匙，这里的i=j是为了跳过时间相同的的状态，因为下面会处理
	
		//记录i~j的范围，这就是同一时刻的借还状态范围
		for(j=i; j<m && P[i].time==P[j].time; j++);//即使不是同一时刻，此式方便j>i
		
		//先将同一时刻的还钥匙状态处理好
		for(int t=i; t<j; t++){
			if(P[t].temp == 1){//如果此人是为了还钥匙
				for(int r=1; r<=n; r++){//从头开始扫描ans数组，将钥匙放在第一个空位
					if(ans[r] == 0){
						ans[r] = P[t].key;
						break;
					}
				}
			}
		}
		
		//再将同一时刻的借钥匙状态处理好
		for(int t=i; t<j; t++){
			if(P[t].temp == 0){//如果此人是为了借钥匙
				for(int r=1; r<=n; r++){//从头开始扫描ans数组，找到要借的钥匙
					if(ans[r] == P[t].key){
						ans[r] = 0;
						break;
					}
				}
			}
		}
	}
	
	for(int i=1; i<=n; i++){
		printf("%d ", ans[i]);
	}
	
	return 0;
}



















