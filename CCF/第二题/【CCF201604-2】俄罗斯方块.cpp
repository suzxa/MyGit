/*
	问题描述:
		俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。
	　　游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一
	轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当
	板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某
	一行全放满了方块，则该行被消除并得分。
	　　在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。
	　　具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。

	输入格式:
		输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的
	方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。
	　　输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表
	示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即
	给定的板块是俄罗斯方块的标准板块）。
	　　第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块
	图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边
	是不一致的（见样例）

	输出格式:
		输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理
	最终的消行。

	样例输入:
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 1 0 0
		0 0 0 0 0 0 1 0 0 0
		0 0 0 0 0 0 1 0 0 0
		1 1 1 0 0 0 1 1 1 1
		0 0 0 0 1 0 0 0 0 0
		0 0 0 0
		0 1 1 1
		0 0 0 1
		0 0 0 0
		3

	样例输出:
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 0 0 0
		0 0 0 0 0 0 0 1 0 0
		0 0 0 0 0 0 1 0 0 0
		0 0 0 0 0 0 1 0 0 0
		1 1 1 1 1 1 1 1 1 1
		0 0 0 0 1 1 0 0 0 0
*/

#include <cstdio>
#include <algorithm>

using namespace std;

int a[17][11];
int b[5][5];

int main(){
	
	for(int i=1; i<=15; i++){
		for(int j=1; j<=10; j++){
			scanf("%d", &a[i][j]);
		}
	}
	
	for(int i=1; i<=10; i++){//最低端添加一行，方便下降到底端时查看。
		a[16][i] = 1;
	}
	
	for(int i=1; i<=4; i++){
		for(int j=1; j<=4; j++){
			scanf("%d", &b[i][j]);
		}
	}
	
	int n;
	scanf("%d", &n);
	
	int d=15;
	for(int i=4; i>0; i--){//从最低行开始。查看每行下降的行数
		int sum=0;
		for(int j=1; j<=4; j++){
			sum += b[i][j];
		}
		if(sum == 0){//一行若没有方块，查看上一行
			continue;
		}
		int t=0;//t放在这里是因为，每次比较的是不同行，t当然每次要清零！
		for(int j=i+1; j<=16; j++){//每行下降，记录下降的行数
			int k;
			for(k=1; k<=4; k++){
				if(b[i][k]+a[j][n+k-1] == 2){
					break;//遇到阻碍，或者到达最后一行，无需再查看其它列
				}
			}
			if(k == 5){
				t++;//自然查找结束，记录这一行下降的行数
			}else{
				break;//若遇到阻碍，无需再往下一行查看，此行停止下降
			}
		}
		d = min(t, d);//找到四行中，哪个下降的行数最小。那个行数就是方块下降的行数。
	}
	
	for(int i=4; i>0; i--){//此时，可以将方块代表的1和0直接加到a数组对应的地方
		for(int j=1; j<=4; j++){
			a[i+d][n+j-1] += b[i][j];
		}
	}
	
	for(int i=1; i<=15; i++){
		for(int j=1; j<=10; j++){
			printf("%d ", a[i][j]);
		}
		printf("\n");
	}
	
	return 0;
}




















